// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/arithmetic.isle
// - src/opts/bitops.isle
// - src/opts/cprop.isle
// - src/opts/extends.isle
// - src/opts/icmp.isle
// - src/opts/remat.isle
// - src/opts/selects.isle
// - src/opts/shifts.isle
// - src/opts/vector.isle
// - /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<i32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_as_i8(&mut self, arg0: u8) -> i8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i32_as_i64(&mut self, arg0: i32) -> i64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u128_as_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_as_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_as_i32(&mut self, arg0: u64) -> i32;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_shr(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_ctz(&mut self, arg0: i64) -> i64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn splat64(&mut self, arg0: u64) -> Constant;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term eq.
pub fn constructor_eq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg1, arg2);
    // Rule at src/prelude_opt.isle line 20.
    return v4;
}

// Generated as internal constructor for term ne.
pub fn constructor_ne<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 21.
    return v4;
}

// Generated as internal constructor for term ult.
pub fn constructor_ult<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 22.
    return v4;
}

// Generated as internal constructor for term ule.
pub fn constructor_ule<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 23.
    return v4;
}

// Generated as internal constructor for term ugt.
pub fn constructor_ugt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 24.
    return v4;
}

// Generated as internal constructor for term uge.
pub fn constructor_uge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 25.
    return v4;
}

// Generated as internal constructor for term slt.
pub fn constructor_slt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 26.
    return v4;
}

// Generated as internal constructor for term sle.
pub fn constructor_sle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 27.
    return v4;
}

// Generated as internal constructor for term sgt.
pub fn constructor_sgt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 28.
    return v4;
}

// Generated as internal constructor for term sge.
pub fn constructor_sge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 29.
    return v4;
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v5,
                args: ref v6,
            } => {
                match v5 {
                    &Opcode::Smin => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v512 =
                                                            constructor_smin(ctx, v481, v37, v39);
                                                        let v513 =
                                                            constructor_splat(ctx, v2.0, v512);
                                                        // Rule at src/opts/vector.isle line 54.
                                                        returns.push(v513);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umin => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v514 =
                                                            constructor_umin(ctx, v481, v37, v39);
                                                        let v515 =
                                                            constructor_splat(ctx, v2.0, v514);
                                                        // Rule at src/opts/vector.isle line 57.
                                                        returns.push(v515);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Smax => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v516 =
                                                            constructor_smax(ctx, v481, v37, v39);
                                                        let v517 =
                                                            constructor_splat(ctx, v2.0, v516);
                                                        // Rule at src/opts/vector.isle line 60.
                                                        returns.push(v517);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umax => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v518 =
                                                            constructor_umax(ctx, v481, v37, v39);
                                                        let v519 =
                                                            constructor_splat(ctx, v2.0, v518);
                                                        // Rule at src/opts/vector.isle line 63.
                                                        returns.push(v519);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Iadd => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v270 = constructor_iadd(ctx, v2.0, v125.1, v7.1);
                                                                                let v271 = constructor_iadd(ctx, v2.0, v125.0, v270);
                                                                                // Rule at src/opts/cprop.isle line 125.
                                                                                returns.push(v271);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v283 = C::u64_sub(ctx, v16, v141);
                                                                                let v284 = C::imm64_masked(ctx, v2.0, v283);
                                                                                let v285 = constructor_iconst(ctx, v2.0, v284);
                                                                                let v287 = constructor_iadd(ctx, v2.0, v125.0, v285);
                                                                                // Rule at src/opts/cprop.isle line 147.
                                                                                returns.push(v287);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v276,
                                                                        imm: v277,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v276 {
                                                                            if v2.0 == v157.0 {
                                                                                let v278 = C::u64_from_imm64(ctx, v277);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v288 = C::u64_add(ctx, v278, v16);
                                                                                let v289 = C::imm64_masked(ctx, v2.0, v288);
                                                                                let v290 = constructor_iconst(ctx, v2.0, v289);
                                                                                let v291 = constructor_isub(ctx, v2.0, v290, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 151.
                                                                                returns.push(v291);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Splat => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v38,
                                                        arg: v39,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Splat = v38 {
                                                            if v2.0 == v11.0 {
                                                                let v481 = C::lane_type(ctx, v2.0);
                                                                let v496 = constructor_iadd(
                                                                    ctx, v481, v37, v39,
                                                                );
                                                                let v497 = constructor_splat(
                                                                    ctx, v2.0, v496,
                                                                );
                                                                // Rule at src/opts/vector.isle line 30.
                                                                returns.push(v497);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                            if v16 == 0x1 {
                                                                if v2.0 == v11.0 {
                                                                    let v55 = constructor_ineg(
                                                                        ctx, v2.0, v37,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 71.
                                                                    returns.push(v55);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 9.
                                                    returns.push(v25);
                                                }
                                                0x1 => {
                                                    let v10 = C::inst_data_etor(ctx, v7.1);
                                                    let mut v10 = v10;
                                                    while let Some(v11) = v10.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } = &v11.1
                                                        {
                                                            if let &Opcode::Bnot = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v56 = constructor_ineg(
                                                                        ctx, v2.0, v39,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 73.
                                                                    returns.push(v56);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                            let v261 = constructor_iadd(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 94.
                                            returns.push(v261);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v188 =
                                                                    C::u64_add(ctx, v24, v16);
                                                                let v189 =
                                                                    C::imm64_masked(ctx, v45, v188);
                                                                let v190 = constructor_iconst(
                                                                    ctx, v45, v189,
                                                                );
                                                                let v191 = C::subsume(ctx, v190);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v191);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 4.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 5.
                                            returns.push(v17);
                                        }
                                    }
                                    let v413 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 6.
                                    returns.push(v413);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v283 = C::u64_sub(ctx, v16, v141);
                                                                                let v284 = C::imm64_masked(ctx, v2.0, v283);
                                                                                let v285 = constructor_iconst(ctx, v2.0, v284);
                                                                                let v286 = constructor_isub(ctx, v2.0, v125.0, v285);
                                                                                // Rule at src/opts/cprop.isle line 143.
                                                                                returns.push(v286);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v272 = C::u64_add(ctx, v141, v16);
                                                                                let v273 = C::imm64_masked(ctx, v2.0, v272);
                                                                                let v274 = constructor_iconst(ctx, v2.0, v273);
                                                                                let v275 = constructor_isub(ctx, v2.0, v125.0, v274);
                                                                                // Rule at src/opts/cprop.isle line 135.
                                                                                returns.push(v275);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v276,
                                                                        imm: v277,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v276 {
                                                                            if v2.0 == v157.0 {
                                                                                let v278 = C::u64_from_imm64(ctx, v277);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v279 = C::u64_sub(ctx, v278, v16);
                                                                                let v280 = C::imm64_masked(ctx, v2.0, v279);
                                                                                let v281 = constructor_iconst(ctx, v2.0, v280);
                                                                                let v282 = constructor_isub(ctx, v2.0, v281, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 139.
                                                                                returns.push(v282);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Splat => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v38,
                                                        arg: v39,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Splat = v38 {
                                                            if v2.0 == v11.0 {
                                                                let v481 = C::lane_type(ctx, v2.0);
                                                                let v498 = constructor_isub(
                                                                    ctx, v481, v37, v39,
                                                                );
                                                                let v499 = constructor_splat(
                                                                    ctx, v2.0, v498,
                                                                );
                                                                // Rule at src/opts/vector.isle line 33.
                                                                returns.push(v499);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            let v52 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v15,
                                                            );
                                                            if v52 == -0x1 {
                                                                if v2.0 == v11.0 {
                                                                    let v55 = constructor_ineg(
                                                                        ctx, v2.0, v37,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 75.
                                                                    returns.push(v55);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 19.
                                                returns.push(v26);
                                            }
                                            let v262 = constructor_isub(ctx, v2.0, v7.1, v7.0);
                                            let v263 = constructor_ineg(ctx, v2.0, v262);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v263);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v192 =
                                                                    C::u64_sub(ctx, v24, v16);
                                                                let v193 =
                                                                    C::imm64_masked(ctx, v45, v192);
                                                                let v194 = constructor_iconst(
                                                                    ctx, v45, v193,
                                                                );
                                                                let v195 = C::subsume(ctx, v194);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v195);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 8.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 14.
                                            returns.push(v17);
                                        }
                                    }
                                    let v413 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 10.
                                    returns.push(v413);
                                }
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/arithmetic.isle line 40.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Imul = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v292 = constructor_imul(ctx, v2.0, v125.1, v7.1);
                                                                            let v293 = constructor_imul(ctx, v2.0, v125.0, v292);
                                                                            // Rule at src/opts/cprop.isle line 156.
                                                                            returns.push(v293);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Splat => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v38,
                                                        arg: v39,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Splat = v38 {
                                                            if v2.0 == v11.0 {
                                                                let v481 = C::lane_type(ctx, v2.0);
                                                                let v500 = constructor_imul(
                                                                    ctx, v481, v37, v39,
                                                                );
                                                                let v501 = constructor_splat(
                                                                    ctx, v2.0, v500,
                                                                );
                                                                // Rule at src/opts/vector.isle line 36.
                                                                returns.push(v501);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ineg => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v38,
                                                        arg: v39,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Ineg = v38 {
                                                            if v2.0 == v11.0 {
                                                                let v40 = constructor_imul(
                                                                    ctx, v2.0, v37, v39,
                                                                );
                                                                let v41 = C::subsume(ctx, v40);
                                                                // Rule at src/opts/arithmetic.isle line 28.
                                                                returns.push(v41);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/arithmetic.isle line 57.
                                                    returns.push(v17);
                                                }
                                                0x1 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 47.
                                                    returns.push(v25);
                                                }
                                                _ => {}
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 66.
                                                returns.push(v26);
                                            }
                                            let v264 = constructor_imul(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 102.
                                            returns.push(v264);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v196 =
                                                                    C::u64_mul(ctx, v24, v16);
                                                                let v197 =
                                                                    C::imm64_masked(ctx, v45, v196);
                                                                let v198 = constructor_iconst(
                                                                    ctx, v45, v197,
                                                                );
                                                                let v199 = C::subsume(ctx, v198);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v199);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v82 = C::simm32(ctx, v23);
                                        if let Some(v83) = v82 {
                                            if v83 == 0x2 {
                                                let v84 = constructor_iadd(ctx, v2.0, v7.1, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 105.
                                                returns.push(v84);
                                            }
                                        }
                                        let v90 = C::imm64_power_of_two(ctx, v23);
                                        if let Some(v91) = v90 {
                                            let v92 = C::imm64(ctx, v91);
                                            let v93 = constructor_iconst(ctx, v2.0, v92);
                                            let v94 = constructor_ishl(ctx, v2.0, v7.1, v93);
                                            // Rule at src/opts/arithmetic.isle line 114.
                                            returns.push(v94);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    if v2.0 == v11.0 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        match v16 {
                                            0x0 => {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 53.
                                                returns.push(v25);
                                            }
                                            0x1 => {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 43.
                                                returns.push(v17);
                                            }
                                            _ => {}
                                        }
                                        let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                        if v52 == -0x1 {
                                            let v53 = constructor_ineg(ctx, v2.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 63.
                                            returns.push(v53);
                                        }
                                    }
                                    let v79 = C::simm32(ctx, v15);
                                    if let Some(v80) = v79 {
                                        if v80 == 0x2 {
                                            let v81 = constructor_iadd(ctx, v2.0, v7.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 103.
                                            returns.push(v81);
                                        }
                                    }
                                    let v85 = C::imm64_power_of_two(ctx, v15);
                                    if let Some(v86) = v85 {
                                        let v87 = C::imm64(ctx, v86);
                                        let v88 = constructor_iconst(ctx, v2.0, v87);
                                        let v89 = constructor_ishl(ctx, v2.0, v7.0, v88);
                                        // Rule at src/opts/arithmetic.isle line 112.
                                        returns.push(v89);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umulhi => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v504 =
                                                            constructor_umulhi(ctx, v481, v37, v39);
                                                        let v505 =
                                                            constructor_splat(ctx, v2.0, v504);
                                                        // Rule at src/opts/vector.isle line 42.
                                                        returns.push(v505);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Smulhi => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Splat = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Splat = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v481 = C::lane_type(ctx, v2.0);
                                                        let v502 =
                                                            constructor_smulhi(ctx, v481, v37, v39);
                                                        let v503 =
                                                            constructor_splat(ctx, v2.0, v502);
                                                        // Rule at src/opts/vector.isle line 39.
                                                        returns.push(v503);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 94.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v205 = C::u64_udiv(ctx, v24, v16);
                                                        if let Some(v206) = v205 {
                                                            if v11.0 == v19.0 {
                                                                let v207 =
                                                                    C::imm64_masked(ctx, v45, v206);
                                                                let v208 = constructor_iconst(
                                                                    ctx, v45, v207,
                                                                );
                                                                let v209 = C::subsume(ctx, v208);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v209);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 90.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v200 = C::u64_sdiv(ctx, v24, v16);
                                                        if let Some(v201) = v200 {
                                                            if v11.0 == v19.0 {
                                                                let v202 =
                                                                    C::imm64_masked(ctx, v45, v201);
                                                                let v203 = constructor_iconst(
                                                                    ctx, v45, v202,
                                                                );
                                                                let v204 = C::subsume(ctx, v203);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v204);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Band = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v296 = constructor_band(ctx, v2.0, v125.1, v7.1);
                                                                            let v297 = constructor_band(ctx, v2.0, v125.0, v296);
                                                                            // Rule at src/opts/cprop.isle line 162.
                                                                            returns.push(v297);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v374,
                                    args: ref v375,
                                    cond: ref v376,
                                } => {
                                    if let &Opcode::Icmp = v374 {
                                        let v10 = C::inst_data_etor(ctx, v7.1);
                                        let mut v10 = v10;
                                        while let Some(v11) = v10.next(ctx) {
                                            match &v11.1 {
                                                &InstructionData::IntCompare {
                                                    opcode: ref v399,
                                                    args: ref v400,
                                                    cond: ref v401,
                                                } => {
                                                    if let &Opcode::Icmp = v399 {
                                                        let v44 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v45) = v44 {
                                                            let v405 = constructor_intcc_comparable(
                                                                ctx, v376, v401,
                                                            );
                                                            if let Some(v406) = v405 {
                                                                if v11.0 == v19.0 {
                                                                    if v11.0 == v45 {
                                                                        let v377 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v375,
                                                                            );
                                                                        let v402 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v400,
                                                                            );
                                                                        if v377.0 == v402.0 {
                                                                            if v377.1 == v402.1 {
                                                                                let v407 = constructor_decompose_intcc(ctx, v376);
                                                                                let v408 = constructor_decompose_intcc(ctx, v401);
                                                                                let v409 =
                                                                                    C::u64_and(
                                                                                        ctx, v407,
                                                                                        v408,
                                                                                    );
                                                                                let v410 = constructor_compose_icmp(ctx, v45, v409, v406, v377.0, v377.1);
                                                                                // Rule at src/opts/icmp.isle line 128.
                                                                                returns.push(v410);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } => {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v372 = C::ty_int(ctx, v2.0);
                                                            if let Some(v373) = v372 {
                                                                // Rule at src/opts/icmp.isle line 39.
                                                                returns.push(v7.0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Splat => {
                                            let v486 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v487) = v486 {
                                                if v2.0 == v19.0 {
                                                    let v10 = C::inst_data_etor(ctx, v7.1);
                                                    let mut v10 = v10;
                                                    while let Some(v11) = v10.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } = &v11.1
                                                        {
                                                            if let &Opcode::Splat = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v481 =
                                                                        C::lane_type(ctx, v2.0);
                                                                    let v488 = constructor_band(
                                                                        ctx, v481, v37, v39,
                                                                    );
                                                                    let v489 = constructor_splat(
                                                                        ctx, v2.0, v488,
                                                                    );
                                                                    // Rule at src/opts/vector.isle line 14.
                                                                    returns.push(v489);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v7.1 == v37 {
                                                        if v19.0 == v47 {
                                                            let v49 = C::imm64(ctx, 0x0);
                                                            let v50 =
                                                                constructor_iconst(ctx, v47, v49);
                                                            let v51 = C::subsume(ctx, v50);
                                                            // Rule at src/opts/bitops.isle line 50.
                                                            returns.push(v51);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v372 = C::ty_int(ctx, v2.0);
                                                            if let Some(v373) = v372 {
                                                                let v380 =
                                                                    C::inst_data_etor(ctx, v37);
                                                                let mut v380 = v380;
                                                                while let Some(v381) =
                                                                    v380.next(ctx)
                                                                {
                                                                    if let &InstructionData::IntCompare {
                                                                        opcode: ref v384,
                                                                        args: ref v385,
                                                                        cond: ref v386,
                                                                    } = &v381.1 {
                                                                        if let &Opcode::Icmp = v384 {
                                                                            // Rule at src/opts/icmp.isle line 44.
                                                                            returns.push(v7.0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        let v333 = C::value_type(ctx, v37);
                                                        let v334 = C::ty_mask(ctx, v333);
                                                        let v335 = C::u64_and(ctx, v16, v334);
                                                        let v336 = C::u64_eq(ctx, v334, v335);
                                                        if v336 == true {
                                                            // Rule at src/opts/extends.isle line 9.
                                                            returns.push(v7.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v333 = C::value_type(ctx, v37);
                                                        let v334 = C::ty_mask(ctx, v333);
                                                        let v337 = C::u64_eq(ctx, v16, v334);
                                                        if v337 == true {
                                                            let v338 =
                                                                constructor_uextend(ctx, v2.0, v37);
                                                            // Rule at src/opts/extends.isle line 15.
                                                            returns.push(v338);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 48.
                                                returns.push(v17);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 42.
                                                returns.push(v25);
                                            }
                                            let v266 = constructor_band(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v266);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v214 =
                                                                    C::u64_and(ctx, v24, v16);
                                                                let v215 =
                                                                    C::imm64_masked(ctx, v45, v214);
                                                                let v216 = constructor_iconst(
                                                                    ctx, v45, v215,
                                                                );
                                                                let v217 = C::subsume(ctx, v216);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v217);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 12.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v49 = C::imm64(ctx, 0x0);
                                                        let v50 = constructor_iconst(ctx, v47, v49);
                                                        let v51 = C::subsume(ctx, v50);
                                                        // Rule at src/opts/bitops.isle line 49.
                                                        returns.push(v51);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 47.
                                                returns.push(v25);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 39.
                                                returns.push(v17);
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 14.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 38.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Band => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                match &v11.1 {
                                                    &InstructionData::Binary {
                                                        opcode: ref v129,
                                                        args: ref v130,
                                                    } => {
                                                        if let &Opcode::Band = v129 {
                                                            let v434 = C::ty_vec128(ctx, v2.0);
                                                            if let Some(v435) = v434 {
                                                                if v11.0 == v19.0 {
                                                                    if v11.0 == v435 {
                                                                        let v125 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v124,
                                                                            );
                                                                        let v135 =
                                                                            C::inst_data_etor(
                                                                                ctx, v125.1,
                                                                            );
                                                                        let mut v135 = v135;
                                                                        while let Some(v136) =
                                                                            v135.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v148,
                                                                                arg: v149,
                                                                            } = &v136.1 {
                                                                                if let &Opcode::Bnot = v148 {
                                                                                    if v11.0 == v136.0 {
                                                                                        let v131 = C::unpack_value_array_2(ctx, v130);
                                                                                        if v131.0 == v149 {
                                                                                            let v454 = constructor_bitselect(ctx, v435, v149, v131.1, v125.0);
                                                                                            // Rule at src/opts/selects.isle line 58.
                                                                                            returns.push(v454);
                                                                                        }
                                                                                        if v131.1 == v149 {
                                                                                            let v455 = constructor_bitselect(ctx, v435, v149, v131.0, v125.0);
                                                                                            // Rule at src/opts/selects.isle line 59.
                                                                                            returns.push(v455);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let v156 =
                                                                            C::inst_data_etor(
                                                                                ctx, v125.0,
                                                                            );
                                                                        let mut v156 = v156;
                                                                        while let Some(v157) =
                                                                            v156.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v160,
                                                                                arg: v161,
                                                                            } = &v157.1 {
                                                                                if let &Opcode::Bnot = v160 {
                                                                                    if v11.0 == v157.0 {
                                                                                        let v131 = C::unpack_value_array_2(ctx, v130);
                                                                                        if v131.0 == v161 {
                                                                                            let v452 = constructor_bitselect(ctx, v435, v161, v131.1, v125.1);
                                                                                            // Rule at src/opts/selects.isle line 56.
                                                                                            returns.push(v452);
                                                                                        }
                                                                                        if v131.1 == v161 {
                                                                                            let v453 = constructor_bitselect(ctx, v435, v161, v131.0, v125.1);
                                                                                            // Rule at src/opts/selects.isle line 57.
                                                                                            returns.push(v453);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let v131 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v130,
                                                                            );
                                                                        let v436 =
                                                                            C::inst_data_etor(
                                                                                ctx, v131.0,
                                                                            );
                                                                        let mut v436 = v436;
                                                                        while let Some(v437) =
                                                                            v436.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v440,
                                                                                arg: v441,
                                                                            } = &v437.1 {
                                                                                if let &Opcode::Bnot = v440 {
                                                                                    if v11.0 == v437.0 {
                                                                                        if v125.0 == v441 {
                                                                                            let v442 = constructor_bitselect(ctx, v435, v125.0, v125.1, v131.1);
                                                                                            // Rule at src/opts/selects.isle line 52.
                                                                                            returns.push(v442);
                                                                                        }
                                                                                        if v125.1 == v441 {
                                                                                            let v450 = constructor_bitselect(ctx, v435, v125.1, v125.0, v131.1);
                                                                                            // Rule at src/opts/selects.isle line 54.
                                                                                            returns.push(v450);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let v443 =
                                                                            C::inst_data_etor(
                                                                                ctx, v131.1,
                                                                            );
                                                                        let mut v443 = v443;
                                                                        while let Some(v444) =
                                                                            v443.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v447,
                                                                                arg: v448,
                                                                            } = &v444.1 {
                                                                                if let &Opcode::Bnot = v447 {
                                                                                    if v11.0 == v444.0 {
                                                                                        if v125.0 == v448 {
                                                                                            let v449 = constructor_bitselect(ctx, v435, v125.0, v125.1, v131.0);
                                                                                            // Rule at src/opts/selects.isle line 53.
                                                                                            returns.push(v449);
                                                                                        }
                                                                                        if v125.1 == v448 {
                                                                                            let v451 = constructor_bitselect(ctx, v435, v125.1, v125.0, v131.0);
                                                                                            // Rule at src/opts/selects.isle line 55.
                                                                                            returns.push(v451);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &InstructionData::Unary {
                                                        opcode: ref v38,
                                                        arg: v39,
                                                    } => {
                                                        if let &Opcode::Bnot = v38 {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    if v39 == v125.1 {
                                                                        let v128 = constructor_bor(
                                                                            ctx, v2.0, v125.0, v7.1,
                                                                        );
                                                                        // Rule at src/opts/bitops.isle line 64.
                                                                        returns.push(v128);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } => {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v139,
                                                                            imm: v140,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Iconst = v139 {
                                                                                let v142 = C::ty_mask(ctx, v2.0);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v143 = C::u64_and(ctx, v142, v16);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v144 = C::u64_not(ctx, v141);
                                                                                let v145 = C::u64_and(ctx, v142, v144);
                                                                                let v146 = C::u64_eq(ctx, v143, v145);
                                                                                if v146 == true {
                                                                                    if v2.0 == v136.0 {
                                                                                        let v128 = constructor_bor(ctx, v2.0, v125.0, v7.1);
                                                                                        // Rule at src/opts/bitops.isle line 84.
                                                                                        returns.push(v128);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v294 = constructor_bor(ctx, v2.0, v125.1, v7.1);
                                                                                let v295 = constructor_bor(ctx, v2.0, v125.0, v294);
                                                                                // Rule at src/opts/cprop.isle line 159.
                                                                                returns.push(v295);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v374,
                                    args: ref v375,
                                    cond: ref v376,
                                } => {
                                    if let &Opcode::Icmp = v374 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::IntCompare {
                                                        opcode: ref v399,
                                                        args: ref v400,
                                                        cond: ref v401,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Icmp = v399 {
                                                            let v405 = constructor_intcc_comparable(
                                                                ctx, v376, v401,
                                                            );
                                                            if let Some(v406) = v405 {
                                                                if v11.0 == v19.0 {
                                                                    let v377 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v375,
                                                                        );
                                                                    let v402 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v400,
                                                                        );
                                                                    if v377.0 == v402.0 {
                                                                        if v377.1 == v402.1 {
                                                                            let v407 = constructor_decompose_intcc(ctx, v376);
                                                                            let v408 = constructor_decompose_intcc(ctx, v401);
                                                                            let v411 = C::u64_or(
                                                                                ctx, v407, v408,
                                                                            );
                                                                            let v412 = constructor_compose_icmp(ctx, v45, v411, v406, v377.0, v377.1);
                                                                            // Rule at src/opts/icmp.isle line 132.
                                                                            returns.push(v412);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Splat => {
                                            let v486 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v487) = v486 {
                                                if v2.0 == v19.0 {
                                                    let v10 = C::inst_data_etor(ctx, v7.1);
                                                    let mut v10 = v10;
                                                    while let Some(v11) = v10.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } = &v11.1
                                                        {
                                                            if let &Opcode::Splat = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v481 =
                                                                        C::lane_type(ctx, v2.0);
                                                                    let v490 = constructor_bor(
                                                                        ctx, v481, v37, v39,
                                                                    );
                                                                    let v491 = constructor_splat(
                                                                        ctx, v2.0, v490,
                                                                    );
                                                                    // Rule at src/opts/vector.isle line 18.
                                                                    returns.push(v491);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v7.1 == v37 {
                                                        if v19.0 == v47 {
                                                            let v115 = C::ty_mask(ctx, v47);
                                                            let v116 = C::imm64(ctx, v115);
                                                            let v117 =
                                                                constructor_iconst(ctx, v47, v116);
                                                            let v118 = C::subsume(ctx, v117);
                                                            // Rule at src/opts/bitops.isle line 35.
                                                            returns.push(v118);
                                                        }
                                                    }
                                                }
                                            }
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v129,
                                                        args: ref v130,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Band = v129 {
                                                            if v2.0 == v11.0 {
                                                                let v131 = C::unpack_value_array_2(
                                                                    ctx, v130,
                                                                );
                                                                if v37 == v131.1 {
                                                                    let v134 = constructor_bor(
                                                                        ctx, v2.0, v131.0, v7.0,
                                                                    );
                                                                    // Rule at src/opts/bitops.isle line 73.
                                                                    returns.push(v134);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 8.
                                                returns.push(v25);
                                            }
                                            let v265 = constructor_bor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v265);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v210 = C::u64_or(ctx, v24, v16);
                                                                let v211 =
                                                                    C::imm64_masked(ctx, v45, v210);
                                                                let v212 = constructor_iconst(
                                                                    ctx, v45, v211,
                                                                );
                                                                let v213 = C::subsume(ctx, v212);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v213);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 16.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 34.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 4.
                                                returns.push(v17);
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 18.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 12.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bxor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    match v38 {
                                        &Opcode::Splat => {
                                            let v486 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v487) = v486 {
                                                if v2.0 == v11.0 {
                                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                                    let mut v18 = v18;
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v36,
                                                            arg: v37,
                                                        } = &v19.1
                                                        {
                                                            if let &Opcode::Splat = v36 {
                                                                if v2.0 == v19.0 {
                                                                    let v481 =
                                                                        C::lane_type(ctx, v2.0);
                                                                    let v492 = constructor_bxor(
                                                                        ctx, v481, v37, v39,
                                                                    );
                                                                    let v493 = constructor_splat(
                                                                        ctx, v2.0, v492,
                                                                    );
                                                                    // Rule at src/opts/vector.isle line 22.
                                                                    returns.push(v493);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v7.0 == v39 {
                                                        if v11.0 == v47 {
                                                            let v115 = C::ty_mask(ctx, v47);
                                                            let v116 = C::imm64(ctx, v115);
                                                            let v117 =
                                                                constructor_iconst(ctx, v47, v116);
                                                            let v118 = C::subsume(ctx, v117);
                                                            // Rule at src/opts/bitops.isle line 32.
                                                            returns.push(v118);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 16.
                                                returns.push(v17);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v147 = constructor_bnot(ctx, v2.0, v7.0);
                                                // Rule at src/opts/bitops.isle line 92.
                                                returns.push(v147);
                                            }
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Bxor = v123 {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v298 = constructor_bxor(ctx, v2.0, v125.1, v7.1);
                                                                            let v299 = constructor_bxor(ctx, v2.0, v125.0, v298);
                                                                            // Rule at src/opts/cprop.isle line 165.
                                                                            returns.push(v299);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v11.0 == v45 {
                                                let v18 = C::inst_data_etor(ctx, v7.0);
                                                let mut v18 = v18;
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v22,
                                                        imm: v23,
                                                    } = &v19.1
                                                    {
                                                        if let &Opcode::Iconst = v22 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v218 =
                                                                    C::u64_xor(ctx, v24, v16);
                                                                let v219 =
                                                                    C::imm64_masked(ctx, v45, v218);
                                                                let v220 = constructor_iconst(
                                                                    ctx, v45, v219,
                                                                );
                                                                let v221 = C::subsume(ctx, v220);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v221);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 22.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v7.1 == v37 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v19.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 33.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 20.
                                                returns.push(v25);
                                            }
                                            let v267 = constructor_bxor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 112.
                                            returns.push(v267);
                                        }
                                        let v413 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 20.
                                        returns.push(v413);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/bitops.isle line 26.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 20.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v36,
                                arg: v37,
                            } = &v19.1
                            {
                                if let &Opcode::Splat = v36 {
                                    if v2.0 == v19.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v520 = constructor_rotl(ctx, v481, v37, v7.1);
                                        let v521 = constructor_splat(ctx, v2.0, v520);
                                        // Rule at src/opts/vector.isle line 68.
                                        returns.push(v521);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 16.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v36,
                                arg: v37,
                            } = &v19.1
                            {
                                if let &Opcode::Splat = v36 {
                                    if v2.0 == v19.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v522 = constructor_rotr(ctx, v481, v37, v7.1);
                                        let v523 = constructor_splat(ctx, v2.0, v522);
                                        // Rule at src/opts/vector.isle line 71.
                                        returns.push(v523);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } => {
                                                    match v123 {
                                                        &Opcode::Ushr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v457 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v458 = C::imm64_shl(ctx, v45, v457, v140);
                                                                                let v459 = constructor_iconst(ctx, v45, v458);
                                                                                let v460 = constructor_band(ctx, v45, v125.0, v459);
                                                                                // Rule at src/opts/shifts.isle line 27.
                                                                                returns.push(v460);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v457 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v458 = C::imm64_shl(ctx, v45, v457, v140);
                                                                                let v459 = constructor_iconst(ctx, v45, v458);
                                                                                let v460 = constructor_band(ctx, v45, v125.0, v459);
                                                                                // Rule at src/opts/shifts.isle line 32.
                                                                                returns.push(v460);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        if v19.0 == v45 {
                                                            let v229 =
                                                                C::imm64_shl(ctx, v45, v23, v15);
                                                            let v230 =
                                                                constructor_iconst(ctx, v45, v229);
                                                            let v231 = C::subsume(ctx, v230);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v231);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 4.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v36,
                                arg: v37,
                            } = &v19.1
                            {
                                if let &Opcode::Splat = v36 {
                                    if v2.0 == v19.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v524 = constructor_ishl(ctx, v481, v37, v7.1);
                                        let v525 = constructor_splat(ctx, v2.0, v524);
                                        // Rule at src/opts/vector.isle line 74.
                                        returns.push(v525);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                if let &Opcode::Ishl = v123 {
                                                    let v125 = C::unpack_value_array_2(ctx, v124);
                                                    let v135 = C::inst_data_etor(ctx, v125.1);
                                                    let mut v135 = v135;
                                                    while let Some(v136) = v135.next(ctx) {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref v139,
                                                            imm: v140,
                                                        } = &v136.1
                                                        {
                                                            if let &Opcode::Iconst = v139 {
                                                                if v15 == v140 {
                                                                    let v44 =
                                                                        C::fits_in_64(ctx, v2.0);
                                                                    if let Some(v45) = v44 {
                                                                        let v46 =
                                                                            C::ty_int(ctx, v45);
                                                                        if let Some(v47) = v46 {
                                                                            if v19.0 == v47 {
                                                                                let v115 =
                                                                                    C::ty_mask(
                                                                                        ctx, v47,
                                                                                    );
                                                                                let v116 = C::imm64(
                                                                                    ctx, v115,
                                                                                );
                                                                                let v461 =
                                                                                    C::imm64_ushr(
                                                                                        ctx, v47,
                                                                                        v116, v140,
                                                                                    );
                                                                                let v462 = constructor_iconst(ctx, v47, v461);
                                                                                let v463 = constructor_band(ctx, v47, v125.0, v462);
                                                                                // Rule at src/opts/shifts.isle line 41.
                                                                                returns.push(v463);
                                                                            }
                                                                        }
                                                                    }
                                                                    let v141 = C::u64_from_imm64(
                                                                        ctx, v140,
                                                                    );
                                                                    let v472 =
                                                                        C::u64_is_zero(ctx, v141);
                                                                    if v472 == false {
                                                                        let v150 =
                                                                            C::ty_bits(ctx, v2.0);
                                                                        let v151 =
                                                                            C::u8_as_u64(ctx, v150);
                                                                        let v473 = C::u64_sub(
                                                                            ctx, v151, v141,
                                                                        );
                                                                        let v474 = constructor_shift_amt_to_type(ctx, v473);
                                                                        if let Some(v475) = v474 {
                                                                            if v2.0 == v19.0 {
                                                                                let v476 = constructor_ireduce(ctx, v475, v125.0);
                                                                                let v478 = constructor_uextend(ctx, v2.0, v476);
                                                                                // Rule at src/opts/shifts.isle line 91.
                                                                                returns.push(v478);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v232 =
                                                                C::imm64_ushr(ctx, v45, v23, v15);
                                                            let v233 =
                                                                constructor_iconst(ctx, v45, v232);
                                                            let v234 = C::subsume(ctx, v233);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v234);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 8.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v36,
                                arg: v37,
                            } = &v19.1
                            {
                                if let &Opcode::Splat = v36 {
                                    if v2.0 == v19.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v526 = constructor_ushr(ctx, v481, v37, v7.1);
                                        let v527 = constructor_splat(ctx, v2.0, v526);
                                        // Rule at src/opts/vector.isle line 77.
                                        returns.push(v527);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                match v123 {
                                                    &Opcode::Bor => {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v154 = C::u64_eq(ctx, v16, v153);
                                                        if v154 == true {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v148,
                                                                            arg: v149,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Ineg = v148 {
                                                                                if v2.0 == v136.0 {
                                                                                    if v125.0 == v149 {
                                                                                        let v155 = constructor_bmask(ctx, v2.0, v125.0);
                                                                                        // Rule at src/opts/bitops.isle line 100.
                                                                                        returns.push(v155);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    let v156 = C::inst_data_etor(
                                                                        ctx, v125.0,
                                                                    );
                                                                    let mut v156 = v156;
                                                                    while let Some(v157) =
                                                                        v156.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v160,
                                                                            arg: v161,
                                                                        } = &v157.1 {
                                                                            if let &Opcode::Ineg = v160 {
                                                                                if v125.1 == v161 {
                                                                                    if v2.0 == v157.0 {
                                                                                        let v162 = constructor_bmask(ctx, v2.0, v161);
                                                                                        // Rule at src/opts/bitops.isle line 104.
                                                                                        returns.push(v162);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &Opcode::Ishl => {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v15 == v140 {
                                                                            let v156 = C::inst_data_etor(ctx, v125.0);
                                                                            let mut v156 = v156;
                                                                            while let Some(v157) = v156.next(ctx) {
                                                                                if let &InstructionData::Unary {
                                                                                    opcode: ref v160,
                                                                                    arg: v161,
                                                                                } = &v157.1 {
                                                                                    match v160 {
                                                                                        &Opcode::Uextend => {
                                                                                            if v2.0 == v157.0 {
                                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                                let v465 = C::ty_bits_u64(ctx, v2.0);
                                                                                                let v464 = C::value_type(ctx, v161);
                                                                                                let v466 = C::ty_bits_u64(ctx, v464);
                                                                                                let v467 = C::u64_sub(ctx, v465, v466);
                                                                                                let v468 = C::u64_eq(ctx, v141, v467);
                                                                                                if v468 == true {
                                                                                                    let v469 = constructor_sextend(ctx, v2.0, v161);
                                                                                                    // Rule at src/opts/shifts.isle line 50.
                                                                                                    returns.push(v469);
                                                                                                }
                                                                                                let v470 = C::u64_lt(ctx, v141, v467);
                                                                                                if v470 == true {
                                                                                                    // Rule at src/opts/shifts.isle line 62.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        &Opcode::Sextend => {
                                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                                            let v465 = C::ty_bits_u64(ctx, v2.0);
                                                                                            let v464 = C::value_type(ctx, v161);
                                                                                            let v466 = C::ty_bits_u64(ctx, v464);
                                                                                            let v467 = C::u64_sub(ctx, v465, v466);
                                                                                            let v471 = C::u64_le(ctx, v141, v467);
                                                                                            if v471 == true {
                                                                                                if v2.0 == v157.0 {
                                                                                                    // Rule at src/opts/shifts.isle line 73.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                            let v472 = C::u64_is_zero(ctx, v141);
                                                                            if v472 == false {
                                                                                let v150 = C::ty_bits(ctx, v2.0);
                                                                                let v151 = C::u8_as_u64(ctx, v150);
                                                                                let v473 = C::u64_sub(ctx, v151, v141);
                                                                                let v474 = constructor_shift_amt_to_type(ctx, v473);
                                                                                if let Some(v475) = v474 {
                                                                                    let v476 = constructor_ireduce(ctx, v475, v125.0);
                                                                                    let v477 = constructor_sextend(ctx, v2.0, v476);
                                                                                    // Rule at src/opts/shifts.isle line 87.
                                                                                    returns.push(v477);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v235 =
                                                                C::imm64_sshr(ctx, v45, v23, v15);
                                                            let v236 =
                                                                constructor_iconst(ctx, v45, v235);
                                                            let v237 = C::subsume(ctx, v236);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v237);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 12.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v36,
                                arg: v37,
                            } = &v19.1
                            {
                                if let &Opcode::Splat = v36 {
                                    if v2.0 == v19.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v528 = constructor_sshr(ctx, v481, v37, v7.1);
                                        let v529 = constructor_splat(ctx, v2.0, v528);
                                        // Rule at src/opts/vector.isle line 80.
                                        returns.push(v529);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fmul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Fneg = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Fneg = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v114 =
                                                            constructor_fmul(ctx, v2.0, v37, v39);
                                                        // Rule at src/opts/arithmetic.isle line 127.
                                                        returns.push(v114);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v169,
                args: ref v170,
                cond: ref v171,
            } => {
                if let &Opcode::Icmp = v169 {
                    match v171 {
                        &IntCC::Equal => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    if v172.0 == v172.1 {
                                        let v343 = C::imm64(ctx, 0x1);
                                        let v346 = constructor_iconst(ctx, v47, v343);
                                        // Rule at src/opts/icmp.isle line 5.
                                        returns.push(v346);
                                    }
                                }
                            }
                            let v172 = C::unpack_value_array_2(ctx, v170);
                            let v175 = C::inst_data_etor(ctx, v172.1);
                            let mut v175 = v175;
                            while let Some(v176) = v175.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v179,
                                    imm: v180,
                                } = &v176.1
                                {
                                    if let &Opcode::Iconst = v179 {
                                        let v181 = C::u64_from_imm64(ctx, v180);
                                        if v181 == 0x0 {
                                            let v252 = C::inst_data_etor(ctx, v172.0);
                                            let mut v252 = v252;
                                            while let Some(v253) = v252.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v339,
                                                    arg: v340,
                                                } = &v253.1
                                                {
                                                    if let &Opcode::Uextend = v339 {
                                                        let v347 = C::inst_data_etor(ctx, v340);
                                                        let mut v347 = v347;
                                                        while let Some(v348) = v347.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v351,
                                                                args: ref v352,
                                                                cond: ref v353,
                                                            } = &v348.1
                                                            {
                                                                if let &Opcode::Icmp = v351 {
                                                                    if v2.0 == v348.0 {
                                                                        let v358 =
                                                                            &C::intcc_complement(
                                                                                ctx, v353,
                                                                            );
                                                                        let v354 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v352,
                                                                            );
                                                                        let v359 = constructor_icmp(
                                                                            ctx, v2.0, v358,
                                                                            v354.0, v354.1,
                                                                        );
                                                                        let v360 =
                                                                            C::subsume(ctx, v359);
                                                                        // Rule at src/opts/icmp.isle line 22.
                                                                        returns.push(v360);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v172 = C::unpack_value_array_2(ctx, v170);
                            let v175 = C::inst_data_etor(ctx, v172.1);
                            let mut v175 = v175;
                            while let Some(v176) = v175.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v179,
                                    imm: v180,
                                } = &v176.1
                                {
                                    if let &Opcode::Iconst = v179 {
                                        let v181 = C::u64_from_imm64(ctx, v180);
                                        if v181 == 0x0 {
                                            let v182 = constructor_truthy(ctx, v172.0);
                                            let mut v182 = v182;
                                            while let Some(v183) = v182.next(ctx) {
                                                let v184 = C::value_type(ctx, v183);
                                                let v49 = C::imm64(ctx, 0x0);
                                                let v185 = constructor_iconst(ctx, v184, v49);
                                                let v186 = constructor_ne(ctx, v2.0, v183, v185);
                                                // Rule at src/opts/bitops.isle line 130.
                                                returns.push(v186);
                                            }
                                            let v252 = C::inst_data_etor(ctx, v172.0);
                                            let mut v252 = v252;
                                            while let Some(v253) = v252.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v339,
                                                    arg: v340,
                                                } = &v253.1
                                                {
                                                    if let &Opcode::Uextend = v339 {
                                                        let v347 = C::inst_data_etor(ctx, v340);
                                                        let mut v347 = v347;
                                                        while let Some(v348) = v347.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v351,
                                                                args: ref v352,
                                                                cond: ref v353,
                                                            } = &v348.1
                                                            {
                                                                if let &Opcode::Icmp = v351 {
                                                                    if v2.0 == v348.0 {
                                                                        let v357 =
                                                                            C::subsume(ctx, v340);
                                                                        // Rule at src/opts/icmp.isle line 17.
                                                                        returns.push(v357);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    if v172.0 == v172.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 6.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                let v395 = C::ty_smin(ctx, v176.0);
                                                let v396 = C::u64_eq(ctx, v181, v395);
                                                if v396 == true {
                                                    let v391 =
                                                        constructor_ne(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 98.
                                                    returns.push(v391);
                                                }
                                                let v397 = C::ty_smax(ctx, v176.0);
                                                let v398 = C::u64_eq(ctx, v181, v397);
                                                if v398 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 118.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 9.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                let v395 = C::ty_smin(ctx, v176.0);
                                                let v396 = C::u64_eq(ctx, v181, v395);
                                                if v396 == true {
                                                    let v343 = C::imm64(ctx, 0x1);
                                                    let v346 = constructor_iconst(ctx, v47, v343);
                                                    let v392 = C::subsume(ctx, v346);
                                                    // Rule at src/opts/icmp.isle line 103.
                                                    returns.push(v392);
                                                }
                                                let v397 = C::ty_smax(ctx, v176.0);
                                                let v398 = C::u64_eq(ctx, v181, v397);
                                                if v398 == true {
                                                    let v390 =
                                                        constructor_eq(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 123.
                                                    returns.push(v390);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v343 = C::imm64(ctx, 0x1);
                                        let v346 = constructor_iconst(ctx, v47, v343);
                                        // Rule at src/opts/icmp.isle line 10.
                                        returns.push(v346);
                                    }
                                }
                            }
                            let v172 = C::unpack_value_array_2(ctx, v170);
                            let v175 = C::inst_data_etor(ctx, v172.1);
                            let mut v175 = v175;
                            while let Some(v176) = v175.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v179,
                                    imm: v180,
                                } = &v176.1
                                {
                                    if let &Opcode::Iconst = v179 {
                                        let v181 = C::u64_from_imm64(ctx, v180);
                                        if v181 == 0x0 {
                                            let v252 = C::inst_data_etor(ctx, v172.0);
                                            let mut v252 = v252;
                                            while let Some(v253) = v252.next(ctx) {
                                                if v253.0 == I64 {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v339,
                                                        arg: v340,
                                                    } = &v253.1
                                                    {
                                                        if let &Opcode::Uextend = v339 {
                                                            let v341 = C::value_type(ctx, v340);
                                                            if v341 == I32 {
                                                                let v343 = C::imm64(ctx, 0x1);
                                                                let v344 = constructor_iconst(
                                                                    ctx, v2.0, v343,
                                                                );
                                                                // Rule at src/opts/extends.isle line 25.
                                                                returns.push(v344);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                let v395 = C::ty_smin(ctx, v176.0);
                                                let v396 = C::u64_eq(ctx, v181, v395);
                                                if v396 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 88.
                                                    returns.push(v51);
                                                }
                                                let v397 = C::ty_smax(ctx, v176.0);
                                                let v398 = C::u64_eq(ctx, v181, v397);
                                                if v398 == true {
                                                    let v391 =
                                                        constructor_ne(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 108.
                                                    returns.push(v391);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 13.
                                        returns.push(v50);
                                    }
                                }
                            }
                            let v172 = C::unpack_value_array_2(ctx, v170);
                            let v175 = C::inst_data_etor(ctx, v172.1);
                            let mut v175 = v175;
                            while let Some(v176) = v175.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v179,
                                    imm: v180,
                                } = &v176.1
                                {
                                    if let &Opcode::Iconst = v179 {
                                        let v181 = C::u64_from_imm64(ctx, v180);
                                        if v181 == 0x0 {
                                            let v252 = C::inst_data_etor(ctx, v172.0);
                                            let mut v252 = v252;
                                            while let Some(v253) = v252.next(ctx) {
                                                if v253.0 == I64 {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v339,
                                                        arg: v340,
                                                    } = &v253.1
                                                    {
                                                        if let &Opcode::Uextend = v339 {
                                                            let v341 = C::value_type(ctx, v340);
                                                            if v341 == I32 {
                                                                let v49 = C::imm64(ctx, 0x0);
                                                                let v342 = constructor_iconst(
                                                                    ctx, v2.0, v49,
                                                                );
                                                                // Rule at src/opts/extends.isle line 20.
                                                                returns.push(v342);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                let v395 = C::ty_smin(ctx, v176.0);
                                                let v396 = C::u64_eq(ctx, v181, v395);
                                                if v396 == true {
                                                    let v390 =
                                                        constructor_eq(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 93.
                                                    returns.push(v390);
                                                }
                                                let v397 = C::ty_smax(ctx, v176.0);
                                                let v398 = C::u64_eq(ctx, v181, v397);
                                                if v398 == true {
                                                    let v343 = C::imm64(ctx, 0x1);
                                                    let v346 = constructor_iconst(ctx, v47, v343);
                                                    let v392 = C::subsume(ctx, v346);
                                                    // Rule at src/opts/icmp.isle line 113.
                                                    returns.push(v392);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v343 = C::imm64(ctx, 0x1);
                                        let v346 = constructor_iconst(ctx, v47, v343);
                                        // Rule at src/opts/icmp.isle line 14.
                                        returns.push(v346);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                if v181 == 0x0 {
                                                    let v391 =
                                                        constructor_ne(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 60.
                                                    returns.push(v391);
                                                }
                                                let v393 = C::ty_umax(ctx, v176.0);
                                                let v394 = C::u64_eq(ctx, v181, v393);
                                                if v394 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 78.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 7.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                if v181 == 0x0 {
                                                    let v343 = C::imm64(ctx, 0x1);
                                                    let v346 = constructor_iconst(ctx, v47, v343);
                                                    let v392 = C::subsume(ctx, v346);
                                                    // Rule at src/opts/icmp.isle line 64.
                                                    returns.push(v392);
                                                }
                                                let v393 = C::ty_umax(ctx, v176.0);
                                                let v394 = C::u64_eq(ctx, v181, v393);
                                                if v394 == true {
                                                    let v390 =
                                                        constructor_eq(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 83.
                                                    returns.push(v390);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v343 = C::imm64(ctx, 0x1);
                                        let v346 = constructor_iconst(ctx, v47, v343);
                                        // Rule at src/opts/icmp.isle line 8.
                                        returns.push(v346);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                if v181 == 0x0 {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 52.
                                                    returns.push(v51);
                                                }
                                                let v393 = C::ty_umax(ctx, v176.0);
                                                let v394 = C::u64_eq(ctx, v181, v393);
                                                if v394 == true {
                                                    let v391 =
                                                        constructor_ne(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 68.
                                                    returns.push(v391);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 11.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v172 = C::unpack_value_array_2(ctx, v170);
                                    let v175 = C::inst_data_etor(ctx, v172.1);
                                    let mut v175 = v175;
                                    while let Some(v176) = v175.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v179,
                                            imm: v180,
                                        } = &v176.1
                                        {
                                            if let &Opcode::Iconst = v179 {
                                                let v181 = C::u64_from_imm64(ctx, v180);
                                                if v181 == 0x0 {
                                                    let v390 =
                                                        constructor_eq(ctx, v47, v172.0, v172.1);
                                                    // Rule at src/opts/icmp.isle line 56.
                                                    returns.push(v390);
                                                }
                                                let v393 = C::ty_umax(ctx, v176.0);
                                                let v394 = C::u64_eq(ctx, v181, v393);
                                                if v394 == true {
                                                    let v343 = C::imm64(ctx, 0x1);
                                                    let v346 = constructor_iconst(ctx, v47, v343);
                                                    let v392 = C::subsume(ctx, v346);
                                                    // Rule at src/opts/icmp.isle line 73.
                                                    returns.push(v392);
                                                }
                                            }
                                        }
                                    }
                                    if v172.0 == v172.1 {
                                        let v343 = C::imm64(ctx, 0x1);
                                        let v346 = constructor_iconst(ctx, v47, v343);
                                        // Rule at src/opts/icmp.isle line 12.
                                        returns.push(v346);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v172 = C::unpack_value_array_2(ctx, v170);
                    let v252 = C::inst_data_etor(ctx, v172.0);
                    let mut v252 = v252;
                    while let Some(v253) = v252.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v256,
                            imm: v257,
                        } = &v253.1
                        {
                            if let &Opcode::Iconst = v256 {
                                let v175 = C::inst_data_etor(ctx, v172.1);
                                let mut v175 = v175;
                                while let Some(v176) = v175.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v179,
                                        imm: v180,
                                    } = &v176.1
                                    {
                                        if let &Opcode::Iconst = v179 {
                                            if v176.0 == v253.0 {
                                                let v258 =
                                                    C::imm64_icmp(ctx, v253.0, v171, v257, v180);
                                                let v259 = constructor_iconst(ctx, v2.0, v258);
                                                let v260 = C::subsume(ctx, v259);
                                                // Rule at src/opts/cprop.isle line 82.
                                                returns.push(v260);
                                            }
                                        }
                                    }
                                }
                                let v268 = &C::intcc_swap_args(ctx, v171);
                                let v269 = constructor_icmp(ctx, v2.0, v268, v172.1, v172.0);
                                // Rule at src/opts/cprop.isle line 116.
                                returns.push(v269);
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v95,
                args: ref v96,
            } => {
                match v95 {
                    &Opcode::Select => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            match &v102.1 {
                                &InstructionData::IntCompare {
                                    opcode: ref v420,
                                    args: ref v421,
                                    cond: ref v422,
                                } => {
                                    if let &Opcode::Icmp = v420 {
                                        match v422 {
                                            &IntCC::SignedGreaterThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 8.
                                                        returns.push(v426);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 22.
                                                        returns.push(v428);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 9.
                                                        returns.push(v426);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 23.
                                                        returns.push(v428);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 12.
                                                        returns.push(v428);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 18.
                                                        returns.push(v426);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 13.
                                                        returns.push(v428);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 19.
                                                        returns.push(v426);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 10.
                                                        returns.push(v427);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 24.
                                                        returns.push(v429);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 11.
                                                        returns.push(v427);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 25.
                                                        returns.push(v429);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 14.
                                                        returns.push(v429);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 20.
                                                        returns.push(v427);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 15.
                                                        returns.push(v429);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 21.
                                                        returns.push(v427);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v105,
                                    arg: v106,
                                } => {
                                    if let &Opcode::Uextend = v105 {
                                        let v361 = C::inst_data_etor(ctx, v106);
                                        let mut v361 = v361;
                                        while let Some(v362) = v361.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v365,
                                                args: ref v366,
                                                cond: ref v367,
                                            } = &v362.1
                                            {
                                                if let &Opcode::Icmp = v365 {
                                                    let v371 = constructor_select(
                                                        ctx, v2.0, v106, v97.1, v97.2,
                                                    );
                                                    // Rule at src/opts/icmp.isle line 29.
                                                    returns.push(v371);
                                                    // Rule at src/opts/icmp.isle line 32.
                                                    returns.push(v371);
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v300,
                                    imm: v301,
                                } => {
                                    if let &Opcode::Iconst = v300 {
                                        let v302 = C::u64_from_imm64(ctx, v301);
                                        if v302 == 0x0 {
                                            // Rule at src/opts/cprop.isle line 172.
                                            returns.push(v97.2);
                                        }
                                        let v303 = C::u64_is_zero(ctx, v302);
                                        if v303 == false {
                                            // Rule at src/opts/cprop.isle line 169.
                                            returns.push(v97.1);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 4.
                            returns.push(v97.1);
                        }
                        let v166 = constructor_truthy(ctx, v97.0);
                        let mut v166 = v166;
                        while let Some(v167) = v166.next(ctx) {
                            let v168 = constructor_select(ctx, v2.0, v167, v97.1, v97.2);
                            // Rule at src/opts/bitops.isle line 128.
                            returns.push(v168);
                        }
                    }
                    &Opcode::Bitselect => {
                        let v430 = C::multi_lane(ctx, v2.0);
                        if let Some(v431) = v430 {
                            let v97 = C::unpack_value_array_3(ctx, v96);
                            let v101 = C::inst_data_etor(ctx, v97.0);
                            let mut v101 = v101;
                            while let Some(v102) = v101.next(ctx) {
                                if let &InstructionData::IntCompare {
                                    opcode: ref v420,
                                    args: ref v421,
                                    cond: ref v422,
                                } = &v102.1
                                {
                                    if let &Opcode::Icmp = v420 {
                                        match v422 {
                                            &IntCC::SignedGreaterThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 28.
                                                        returns.push(v426);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 42.
                                                        returns.push(v428);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 29.
                                                        returns.push(v426);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 43.
                                                        returns.push(v428);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 32.
                                                        returns.push(v428);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 38.
                                                        returns.push(v426);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v428 = constructor_smin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 33.
                                                        returns.push(v428);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v426 = constructor_smax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 39.
                                                        returns.push(v426);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 30.
                                                        returns.push(v427);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 44.
                                                        returns.push(v429);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 31.
                                                        returns.push(v427);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 45.
                                                        returns.push(v429);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 34.
                                                        returns.push(v429);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 40.
                                                        returns.push(v427);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v423 = C::unpack_value_array_2(ctx, v421);
                                                if v97.1 == v423.0 {
                                                    if v97.2 == v423.1 {
                                                        let v429 = constructor_umin(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 35.
                                                        returns.push(v429);
                                                    }
                                                }
                                                if v97.1 == v423.1 {
                                                    if v97.2 == v423.0 {
                                                        let v427 = constructor_umax(
                                                            ctx, v2.0, v423.0, v423.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 41.
                                                        returns.push(v427);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 5.
                            returns.push(v97.1);
                        }
                    }
                    &Opcode::Fma => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v105,
                                arg: v106,
                            } = &v102.1
                            {
                                if let &Opcode::Fneg = v105 {
                                    if v2.0 == v102.0 {
                                        let v107 = C::inst_data_etor(ctx, v97.1);
                                        let mut v107 = v107;
                                        while let Some(v108) = v107.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v111,
                                                arg: v112,
                                            } = &v108.1
                                            {
                                                if let &Opcode::Fneg = v111 {
                                                    if v2.0 == v108.0 {
                                                        let v113 = constructor_fma(
                                                            ctx, v2.0, v106, v112, v97.2,
                                                        );
                                                        // Rule at src/opts/arithmetic.isle line 122.
                                                        returns.push(v113);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v27,
                arg: v28,
            } => {
                match v27 {
                    &Opcode::Splat => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::UnaryIeee32 {
                                    opcode: ref v320,
                                    imm: v321,
                                } => {
                                    if let &Opcode::F32const = v320 {
                                        let v322 = C::u32_from_ieee32(ctx, v321);
                                        let v323 = C::u32_as_u64(ctx, v322);
                                        let v324 = constructor_splat32(ctx, v323);
                                        let v325 = constructor_vconst(ctx, v2.0, v324);
                                        // Rule at src/opts/cprop.isle line 188.
                                        returns.push(v325);
                                    }
                                }
                                &InstructionData::UnaryIeee64 {
                                    opcode: ref v326,
                                    imm: v327,
                                } => {
                                    if let &Opcode::F64const = v326 {
                                        let v328 = C::u64_from_ieee64(ctx, v327);
                                        let v329 = C::splat64(ctx, v328);
                                        let v330 = constructor_vconst(ctx, v2.0, v329);
                                        // Rule at src/opts/cprop.isle line 190.
                                        returns.push(v330);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        match v30.0 {
                                            I8 => {
                                                let v305 = C::u64_uextend_imm64(ctx, I8, v223);
                                                let v306 = constructor_splat8(ctx, v305);
                                                let v307 = constructor_vconst(ctx, v2.0, v306);
                                                // Rule at src/opts/cprop.isle line 180.
                                                returns.push(v307);
                                            }
                                            I16 => {
                                                let v309 = C::u64_uextend_imm64(ctx, I16, v223);
                                                let v310 = constructor_splat16(ctx, v309);
                                                let v311 = constructor_vconst(ctx, v2.0, v310);
                                                // Rule at src/opts/cprop.isle line 182.
                                                returns.push(v311);
                                            }
                                            I32 => {
                                                let v313 = C::u64_uextend_imm64(ctx, I32, v223);
                                                let v314 = constructor_splat32(ctx, v313);
                                                let v315 = constructor_vconst(ctx, v2.0, v314);
                                                // Rule at src/opts/cprop.isle line 184.
                                                returns.push(v315);
                                            }
                                            I64 => {
                                                let v317 = C::u64_uextend_imm64(ctx, I64, v223);
                                                let v318 = C::splat64(ctx, v317);
                                                let v319 = constructor_vconst(ctx, v2.0, v318);
                                                // Rule at src/opts/cprop.isle line 186.
                                                returns.push(v319);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Ineg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    if let &Opcode::Ushr = v57 {
                                        if v2.0 == v30.0 {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v62 = C::inst_data_etor(ctx, v59.1);
                                            let mut v62 = v62;
                                            while let Some(v63) = v62.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v66,
                                                    imm: v67,
                                                } = &v63.1
                                                {
                                                    if let &Opcode::Iconst = v66 {
                                                        let v68 = C::u64_from_imm64(ctx, v67);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v479 = C::u64_eq(ctx, v68, v153);
                                                        if v479 == true {
                                                            if v2.0 == v63.0 {
                                                                let v480 = constructor_sshr(
                                                                    ctx, v2.0, v59.0, v59.1,
                                                                );
                                                                // Rule at src/opts/shifts.isle line 102.
                                                                returns.push(v480);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    match v33 {
                                        &Opcode::Splat => {
                                            if v2.0 == v30.0 {
                                                let v481 = C::lane_type(ctx, v2.0);
                                                let v506 = constructor_ineg(ctx, v481, v34);
                                                let v507 = constructor_splat(ctx, v2.0, v506);
                                                // Rule at src/opts/vector.isle line 45.
                                                returns.push(v507);
                                            }
                                        }
                                        &Opcode::Ineg => {
                                            if v2.0 == v30.0 {
                                                let v35 = C::subsume(ctx, v34);
                                                // Rule at src/opts/arithmetic.isle line 25.
                                                returns.push(v35);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Iabs => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                match v33 {
                                    &Opcode::Splat => {
                                        if v2.0 == v30.0 {
                                            let v481 = C::lane_type(ctx, v2.0);
                                            let v508 = constructor_iabs(ctx, v481, v34);
                                            let v509 = constructor_splat(ctx, v2.0, v508);
                                            // Rule at src/opts/vector.isle line 48.
                                            returns.push(v509);
                                        }
                                    }
                                    &Opcode::Ineg => {
                                        if v2.0 == v30.0 {
                                            let v42 = constructor_iabs(ctx, v2.0, v34);
                                            // Rule at src/opts/arithmetic.isle line 32.
                                            returns.push(v42);
                                        }
                                    }
                                    &Opcode::Iabs => {
                                        if v2.0 == v30.0 {
                                            let v43 = C::subsume(ctx, v28);
                                            // Rule at src/opts/arithmetic.isle line 36.
                                            returns.push(v43);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Bnot => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    match v57 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v70 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v67,
                                                            );
                                                            if v70 == -0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 82.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let v71 = C::inst_data_etor(ctx, v59.0);
                                                let mut v71 = v71;
                                                while let Some(v72) = v71.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v75,
                                                        imm: v76,
                                                    } = &v72.1
                                                    {
                                                        if let &Opcode::Iconst = v75 {
                                                            let v77 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v76,
                                                            );
                                                            if v77 == -0x1 {
                                                                if v2.0 == v72.0 {
                                                                    let v78 = constructor_ineg(
                                                                        ctx, v2.0, v59.1,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 85.
                                                                    returns.push(v78);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v68 = C::u64_from_imm64(ctx, v67);
                                                            if v68 == 0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 80.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Band => {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                            let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                            let v122 = constructor_bor(ctx, v2.0, v119, v120);
                                            // Rule at src/opts/bitops.isle line 60.
                                            returns.push(v122);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                                let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                                let v121 = constructor_band(ctx, v2.0, v119, v120);
                                                // Rule at src/opts/bitops.isle line 57.
                                                returns.push(v121);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    match v33 {
                                        &Opcode::Splat => {
                                            let v486 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v487) = v486 {
                                                if v2.0 == v30.0 {
                                                    let v481 = C::lane_type(ctx, v2.0);
                                                    let v494 = constructor_bnot(ctx, v481, v34);
                                                    let v495 = constructor_splat(ctx, v2.0, v494);
                                                    // Rule at src/opts/vector.isle line 26.
                                                    returns.push(v495);
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v30.0 {
                                                let v35 = C::subsume(ctx, v34);
                                                // Rule at src/opts/bitops.isle line 53.
                                                returns.push(v35);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v30.0 == v45 {
                                                let v224 = C::u64_from_imm64(ctx, v223);
                                                let v225 = C::u64_not(ctx, v224);
                                                let v226 = C::imm64_masked(ctx, v45, v225);
                                                let v227 = constructor_iconst(ctx, v45, v226);
                                                let v228 = C::subsume(ctx, v227);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v228);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v413 = C::remat(ctx, arg0);
                        // Rule at src/opts/remat.isle line 24.
                        returns.push(v413);
                    }
                    &Opcode::Bitrev => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Bitrev = v33 {
                                    if v2.0 == v30.0 {
                                        let v35 = C::subsume(ctx, v34);
                                        // Rule at src/opts/bitops.isle line 147.
                                        returns.push(v35);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bswap => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Bswap = v33 {
                                    if v2.0 == v30.0 {
                                        let v35 = C::subsume(ctx, v34);
                                        // Rule at src/opts/bitops.isle line 144.
                                        returns.push(v35);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Popcnt => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    if v2.0 == v30.0 {
                                        let v481 = C::lane_type(ctx, v2.0);
                                        let v510 = constructor_popcnt(ctx, v481, v34);
                                        let v511 = constructor_splat(ctx, v2.0, v510);
                                        // Rule at src/opts/vector.isle line 51.
                                        returns.push(v511);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fneg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Fneg = v33 {
                                    if v2.0 == v30.0 {
                                        let v35 = C::subsume(ctx, v34);
                                        // Rule at src/opts/arithmetic.isle line 118.
                                        returns.push(v35);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bmask => {
                        let v163 = constructor_truthy(ctx, v28);
                        let mut v163 = v163;
                        while let Some(v164) = v163.next(ctx) {
                            let v165 = constructor_bmask(ctx, v2.0, v164);
                            // Rule at src/opts/bitops.isle line 127.
                            returns.push(v165);
                        }
                    }
                    &Opcode::Ireduce => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    match v33 {
                                        &Opcode::Bmask => {
                                            let v187 = constructor_bmask(ctx, v2.0, v34);
                                            // Rule at src/opts/bitops.isle line 141.
                                            returns.push(v187);
                                        }
                                        &Opcode::Uextend => {
                                            let v345 = C::value_type(ctx, v34);
                                            if v2.0 == v345 {
                                                // Rule at src/opts/extends.isle line 34.
                                                returns.push(v34);
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v345 = C::value_type(ctx, v34);
                                            if v2.0 == v345 {
                                                // Rule at src/opts/extends.isle line 33.
                                                returns.push(v34);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        let v238 = C::fits_in_64(ctx, v30.0);
                                        if let Some(v239) = v238 {
                                            let v224 = C::u64_from_imm64(ctx, v223);
                                            let v240 = C::imm64_masked(ctx, v2.0, v224);
                                            let v241 = constructor_iconst(ctx, v2.0, v240);
                                            let v242 = C::subsume(ctx, v241);
                                            // Rule at src/opts/cprop.isle line 73.
                                            returns.push(v242);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::SwidenLow => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v530 = constructor_sextend(ctx, v481, v34);
                                    let v531 = constructor_splat(ctx, v2.0, v530);
                                    // Rule at src/opts/vector.isle line 85.
                                    returns.push(v531);
                                }
                            }
                        }
                    }
                    &Opcode::SwidenHigh => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v530 = constructor_sextend(ctx, v481, v34);
                                    let v531 = constructor_splat(ctx, v2.0, v530);
                                    // Rule at src/opts/vector.isle line 84.
                                    returns.push(v531);
                                }
                            }
                        }
                    }
                    &Opcode::UwidenLow => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v532 = constructor_uextend(ctx, v481, v34);
                                    let v533 = constructor_splat(ctx, v2.0, v532);
                                    // Rule at src/opts/vector.isle line 88.
                                    returns.push(v533);
                                }
                            }
                        }
                    }
                    &Opcode::UwidenHigh => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v532 = constructor_uextend(ctx, v481, v34);
                                    let v533 = constructor_splat(ctx, v2.0, v532);
                                    // Rule at src/opts/vector.isle line 87.
                                    returns.push(v533);
                                }
                            }
                        }
                    }
                    &Opcode::Uextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Uextend = v33 {
                                        let v331 = constructor_uextend(ctx, v2.0, v34);
                                        // Rule at src/opts/extends.isle line 2.
                                        returns.push(v331);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v243 = C::u64_uextend_imm64(ctx, v30.0, v223);
                                            let v244 = C::imm64(ctx, v243);
                                            let v245 = constructor_iconst(ctx, v45, v244);
                                            let v246 = C::subsume(ctx, v245);
                                            // Rule at src/opts/cprop.isle line 76.
                                            returns.push(v246);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    match v33 {
                                        &Opcode::Bmask => {
                                            let v187 = constructor_bmask(ctx, v2.0, v34);
                                            // Rule at src/opts/bitops.isle line 140.
                                            returns.push(v187);
                                        }
                                        &Opcode::Sextend => {
                                            let v332 = constructor_sextend(ctx, v2.0, v34);
                                            // Rule at src/opts/extends.isle line 4.
                                            returns.push(v332);
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v247 = C::i64_sextend_imm64(ctx, v30.0, v223);
                                            let v248 = C::i64_as_u64(ctx, v247);
                                            let v249 = C::imm64_masked(ctx, v45, v248);
                                            let v250 = constructor_iconst(ctx, v45, v249);
                                            let v251 = C::subsume(ctx, v250);
                                            // Rule at src/opts/cprop.isle line 79.
                                            returns.push(v251);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::FcvtFromUint => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v482 = constructor_fcvt_from_uint(ctx, v481, v34);
                                    let v483 = constructor_splat(ctx, v2.0, v482);
                                    // Rule at src/opts/vector.isle line 6.
                                    returns.push(v483);
                                }
                            }
                        }
                    }
                    &Opcode::FcvtFromSint => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v481 = C::lane_type(ctx, v2.0);
                                    let v484 = constructor_fcvt_from_sint(ctx, v481, v34);
                                    let v485 = constructor_splat(ctx, v2.0, v484);
                                    // Rule at src/opts/vector.isle line 8.
                                    returns.push(v485);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v416,
                imm: v417,
            } => {
                if let &Opcode::F32const = v416 {
                    let v413 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 28.
                    returns.push(v413);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v418,
                imm: v419,
            } => {
                if let &Opcode::F64const = v418 {
                    let v413 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 30.
                    returns.push(v413);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v414,
                imm: v415,
            } => {
                if let &Opcode::Iconst = v414 {
                    let v413 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 26.
                    returns.push(v413);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term truthy.
pub fn constructor_truthy<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v7,
                args: ref v8,
            } => {
                match v7 {
                    &Opcode::Rotl => {
                        let v9 = C::unpack_value_array_2(ctx, v8);
                        // Rule at src/opts/bitops.isle line 119.
                        returns.push(v9.0);
                    }
                    &Opcode::Rotr => {
                        let v9 = C::unpack_value_array_2(ctx, v8);
                        // Rule at src/opts/bitops.isle line 120.
                        returns.push(v9.0);
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v33,
                args: ref v34,
                cond: ref v35,
            } => {
                if let &Opcode::Icmp = v33 {
                    if let &IntCC::NotEqual = v35 {
                        let v36 = C::unpack_value_array_2(ctx, v34);
                        let v39 = C::inst_data_etor(ctx, v36.1);
                        let mut v39 = v39;
                        while let Some(v40) = v39.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v43,
                                imm: v44,
                            } = &v40.1
                            {
                                if let &Opcode::Iconst = v43 {
                                    let v45 = C::u64_from_imm64(ctx, v44);
                                    if v45 == 0x0 {
                                        // Rule at src/opts/bitops.isle line 123.
                                        returns.push(v36.0);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v12,
                args: ref v13,
            } => {
                if let &Opcode::Select = v12 {
                    let v14 = C::unpack_value_array_3(ctx, v13);
                    let v18 = C::inst_data_etor(ctx, v14.1);
                    let mut v18 = v18;
                    while let Some(v19) = v18.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v22,
                            imm: v23,
                        } = &v19.1
                        {
                            if let &Opcode::Iconst = v22 {
                                let v24 = C::u64_from_imm64(ctx, v23);
                                let v25 = C::u64_is_zero(ctx, v24);
                                if v25 == false {
                                    let v26 = C::inst_data_etor(ctx, v14.2);
                                    let mut v26 = v26;
                                    while let Some(v27) = v26.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v30,
                                            imm: v31,
                                        } = &v27.1
                                        {
                                            if let &Opcode::Iconst = v30 {
                                                let v32 = C::u64_from_imm64(ctx, v31);
                                                if v32 == 0x0 {
                                                    // Rule at src/opts/bitops.isle line 121.
                                                    returns.push(v14.0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref v5,
                arg: v6,
            } => {
                match v5 {
                    &Opcode::Ineg => {
                        // Rule at src/opts/bitops.isle line 115.
                        returns.push(v6);
                    }
                    &Opcode::Bitrev => {
                        // Rule at src/opts/bitops.isle line 117.
                        returns.push(v6);
                    }
                    &Opcode::Bswap => {
                        // Rule at src/opts/bitops.isle line 116.
                        returns.push(v6);
                    }
                    &Opcode::Popcnt => {
                        // Rule at src/opts/bitops.isle line 118.
                        returns.push(v6);
                    }
                    &Opcode::Bmask => {
                        // Rule at src/opts/bitops.isle line 114.
                        returns.push(v6);
                    }
                    &Opcode::Uextend => {
                        // Rule at src/opts/bitops.isle line 113.
                        returns.push(v6);
                    }
                    &Opcode::Sextend => {
                        // Rule at src/opts/bitops.isle line 112.
                        returns.push(v6);
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term splat8.
pub fn constructor_splat8<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x8);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat16(ctx, v3);
    // Rule at src/opts/cprop.isle line 194.
    return v4;
}

// Generated as internal constructor for term splat16.
pub fn constructor_splat16<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x10);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat32(ctx, v3);
    // Rule at src/opts/cprop.isle line 196.
    return v4;
}

// Generated as internal constructor for term splat32.
pub fn constructor_splat32<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x20);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = C::splat64(ctx, v3);
    // Rule at src/opts/cprop.isle line 198.
    return v4;
}

// Generated as internal constructor for term intcc_comparable.
pub fn constructor_intcc_comparable<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &IntCC,
) -> Option<bool> {
    let v2 = constructor_intcc_class(ctx, arg0);
    let v3 = constructor_intcc_class(ctx, arg1);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::u64_is_zero(ctx, v4);
    if v5 == false {
        let v7 = C::u64_eq(ctx, 0x2, v4);
        // Rule at src/opts/icmp.isle line 137.
        return Some(v7);
    }
    None
}

// Generated as internal constructor for term decompose_intcc.
pub fn constructor_decompose_intcc<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 142.
            return 0x1;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 151.
            return 0x6;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 148.
            return 0x4;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 150.
            return 0x5;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 144.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 146.
            return 0x3;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 147.
            return 0x4;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 149.
            return 0x5;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 143.
            return 0x2;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 145.
            return 0x3;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "decompose_intcc", "src/opts/icmp.isle line 141"
    )
}

// Generated as internal constructor for term compose_icmp.
pub fn constructor_compose_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
    arg2: bool,
    arg3: Value,
    arg4: Value,
) -> Value {
    match arg1 {
        0x0 => {
            let v6 = C::imm64(ctx, 0x0);
            let v7 = constructor_iconst(ctx, arg0, v6);
            let v8 = C::subsume(ctx, v7);
            // Rule at src/opts/icmp.isle line 154.
            return v8;
        }
        0x1 => {
            let v10 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg3, arg4);
            // Rule at src/opts/icmp.isle line 155.
            return v10;
        }
        0x2 => {
            match arg2 {
                true => {
                    let v14 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 157.
                    return v14;
                }
                false => {
                    let v12 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 156.
                    return v12;
                }
                _ => {}
            }
        }
        0x3 => {
            match arg2 {
                true => {
                    let v18 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 159.
                    return v18;
                }
                false => {
                    let v16 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 158.
                    return v16;
                }
                _ => {}
            }
        }
        0x4 => {
            match arg2 {
                true => {
                    let v22 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 161.
                    return v22;
                }
                false => {
                    let v20 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 160.
                    return v20;
                }
                _ => {}
            }
        }
        0x5 => {
            match arg2 {
                true => {
                    let v26 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 163.
                    return v26;
                }
                false => {
                    let v24 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 162.
                    return v24;
                }
                _ => {}
            }
        }
        0x6 => {
            let v28 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg3, arg4);
            // Rule at src/opts/icmp.isle line 164.
            return v28;
        }
        0x7 => {
            let v30 = C::imm64(ctx, 0x1);
            let v31 = constructor_iconst(ctx, arg0, v30);
            let v32 = C::subsume(ctx, v31);
            // Rule at src/opts/icmp.isle line 165.
            return v32;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "compose_icmp", "src/opts/icmp.isle line 153"
    )
}

// Generated as internal constructor for term intcc_class.
pub fn constructor_intcc_class<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 176.
            return 0x3;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 177.
            return 0x3;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 174.
            return 0x2;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 175.
            return 0x2;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 172.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 173.
            return 0x2;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 170.
            return 0x1;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 171.
            return 0x1;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 168.
            return 0x1;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 169.
            return 0x1;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "intcc_class", "src/opts/icmp.isle line 167"
    )
}

// Generated as internal constructor for term shift_amt_to_type.
pub fn constructor_shift_amt_to_type<C: Context>(ctx: &mut C, arg0: u64) -> Option<Type> {
    match arg0 {
        0x8 => {
            // Rule at src/opts/shifts.isle line 97.
            return Some(I8);
        }
        0x10 => {
            // Rule at src/opts/shifts.isle line 98.
            return Some(I16);
        }
        0x20 => {
            // Rule at src/opts/shifts.isle line 99.
            return Some(I32);
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 361.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 370.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 379.
    return v6;
}

// Generated as internal constructor for term x86_pshufb.
pub fn constructor_x86_pshufb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pshufb,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 388.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 397.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 406.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 415.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 424.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 433.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 442.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 451.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 460.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 469.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 478.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 487.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 496.
    return v6;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 505.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 514.
    return v6;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 523.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 532.
    return v6;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 541.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 550.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 559.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 568.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 577.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 586.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 595.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 604.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 613.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 622.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 631.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 640.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 649.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 658.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 667.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 676.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 685.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 694.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 703.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 712.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 721.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 730.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 739.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 748.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 757.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 766.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 775.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 784.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 793.
    return v7;
}

// Generated as internal constructor for term x86_blendv.
pub fn constructor_x86_blendv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::X86Blendv,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 802.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 811.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 820.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 829.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 838.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 847.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 856.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 865.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 874.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 883.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 892.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 901.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 910.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 919.
    return v6;
}

// Generated as internal constructor for term x86_pmulhrsw.
pub fn constructor_x86_pmulhrsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmulhrsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 928.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 937.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 946.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 955.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 964.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 973.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 982.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 991.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1000.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1009.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1018.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1027.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1036.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1045.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1054.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1063.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1072.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1081.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1090.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1099.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1108.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1117.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1126.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1135.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1144.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1153.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1162.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1171.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1180.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1189.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1198.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1207.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1216.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1225.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1234.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1243.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1252.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1261.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1270.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1279.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1288.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1297.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1306.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1315.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1324.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1333.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1342.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1351.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1360.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1369.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1378.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1387.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1396.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1405.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1414.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1423.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1432.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1441.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1450.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1459.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1468.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1477.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1486.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1495.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1504.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1513.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1522.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1531.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1540.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1549.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1558.
    return v6;
}

// Generated as internal constructor for term x86_pmaddubsw.
pub fn constructor_x86_pmaddubsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmaddubsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1567.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1576.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1585.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1594.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1603.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1612.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1621.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1630.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1639.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1648.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1657.
    return v4;
}

// Generated as internal constructor for term x86_cvtt2dq.
pub fn constructor_x86_cvtt2dq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::X86Cvtt2dq,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1666.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1675.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1684.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1693.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1702.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1711.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1720.
    return v5;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/talzisckind/Downloads/vm-parallel-process-7/execution/target/debug/build/cranelift-codegen-c7c0aa294273e2a7/out/clif_opt.isle line 1729.
    return v5;
}
